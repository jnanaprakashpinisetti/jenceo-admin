// StaffBioDataForm.js - FULLY FIXED VERSION
import React, { useEffect, useRef, useState, useCallback } from "react";
import firebaseDB, { storageRef, uploadFile } from "../../firebase";

import BasicInformation from "./BasicInformation";
import PermanentAddress from "./PermanentAddress";
import PresentAddress from "./PresentAddress";
import PersonalInformation from "./PersonalInformation";
import QualificationSkills from "./QualificationSkills";
import HealthDetails from "./HealthDetails";
import EmergencyContact1 from "./EmergencyContact1";
import EmergencyContact2 from "./EmergencyContact2";
import EmergencyContact3 from "./EmergencyContact3";
import BankDetails from "./BankDetails";
import Designation from "./Designation";
import SalaryProfile from "./SalaryProfile";

import "../../scss/components/_WorkerBioDataForm.scss";

const DEFAULT_PHOTO_URL =
  "https://firebasestorage.googleapis.com/v0/b/jenceo-admin.firebasestorage.app/o/OfficeFiles%2FSample-Photo.jpg?alt=media&token=01855b47-c9c2-490e-b400-05851192dde7";

const TOTAL_STEPS = 12;

const initialFormData = {
  idNo: "",
  date: "",
  firstName: "",
  lastName: "",
  gender: "",
  dateOfBirth: "",
  years: "",
  co: "",
  mobileNo1: "",
  mobileNo2: "",
  aadharNo: "",
  localId: "",
  permanentAddress: "",
  permanentStreet: "",
  permanentLandmark: "",
  permanentVillage: "",
  permanentMandal: "",
  permanentDistrict: "",
  permanentState: "",
  permanentPincode: "",
  presentAddress: "",
  presentStreet: "",
  presentLandmark: "",
  presentVillage: "",
  presentMandal: "",
  presentDistrict: "",
  presentState: "",
  presentPincode: "",
  maritalStatus: "",
  dateOfMarriage: "",
  marriageYears: "",
  childName1: "",
  childName2: "",
  religion: "",
  cast: "",
  qualification: "",
  schoolCollege: "",
  primarySkill: "",
  workExperince: "",
  motherTongue: "",
  languages: "",
  healthIssues: [],
  otherIssues: "",
  healthCardNo: "",
  bloodGroup: "",
  height: "",
  weight: "",
  emergencyContact1: { 
    name: "", relation: "", address: "", village: "", mandal: "", state: "", mobile1: "", mobile2: "" 
  },
  emergencyContact2: { 
    name: "", relation: "", address: "", village: "", mandal: "", state: "", mobile1: "", mobile2: "" 
  },
  emergencyContact3: { 
    name: "", relation: "", address: "", village: "", mandal: "", state: "", mobile1: "", mobile2: "" 
  },
  accountNo: "",
  bankName: "",
  branchName: "",
  ifscCode: "",
  phonePayNo: "",
  phonePayName: "",
  googlePayNo: "",
  googlePayName: "",
  basicSalary: "",
  pageNo: "",
  aboutEmployee: "",
  employeePhoto: null,
  employeePhotoFile: null,
  department: "",
  designation: "",
  superiorId: "",
  superiorName: "",
  allowance: "",
  hra: "",
  travelAllowance: "",
  panNo: "",
  pfNo: "",
  insuranceNo: "",
  userId: "",
  password: "",
  role: "",
  
  // ID Proof fields
  idProof: [],
  idProofFiles: [],
  idProofPreviews: [],
  
  // Salary Profile fields
  salaryBreakdown: {
    basic: "0",
    hra: "0",
    da: "0",
    ta: "0",
    medical: "0",
    specialAllowance: "0",
    otherAllowances: "0",
    totalEarnings: "0"
  },
  deductions: {
    pf: "0",
    esi: "0",
    tds: "0",
    otherDeductions: "0",
    totalDeductions: "0"
  },
  netSalary: "0",
  salaryEffectiveDate: "",
  paymentMode: "",
  rating: 0,
  
  // Audit fields
  createdById: "",
  createdByName: "",
  createdAt: "",
  updatedById: "",
  updatedByName: "",
  updatedAt: ""
};

// Helper function to clean undefined values
const cleanUndefinedValues = (obj) => {
  if (obj === null || obj === undefined) return null;
  
  if (Array.isArray(obj)) {
    return obj.map(item => cleanUndefinedValues(item));
  }
  
  if (typeof obj === 'object') {
    const cleaned = {};
    Object.keys(obj).forEach(key => {
      const value = obj[key];
      if (value === undefined) {
        cleaned[key] = null;
      } else if (value === null) {
        cleaned[key] = null;
      } else if (typeof value === 'object') {
        cleaned[key] = cleanUndefinedValues(value);
      } else {
        cleaned[key] = value;
      }
    });
    return cleaned;
  }
  
  return obj;
};

const StaffBioDataForm = ({ isOpen = false, onClose = () => { }, onSaved }) => {
  const [step, setStep] = useState(1);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isMobile, setIsMobile] = useState(false);

  const [existingEmployee, setExistingEmployee] = useState(null);
  const [showIdExistsModal, setShowIdExistsModal] = useState(false);

  const [successOpen, setSuccessOpen] = useState(false);
  const [successInfo, setSuccessInfo] = useState({ idNo: "", name: "", recordId: "" });

  const [uploadProgress, setUploadProgress] = useState({});

  const firstRender = useRef(true);
  const [formData, setFormData] = useState({ ...initialFormData });
  const [idAutoGenerated, setIdAutoGenerated] = useState(false);

  // Helper functions
  const validateMobileNumber = useCallback((mobile) => /^\d{10}$/.test(String(mobile || "")), []);
  const validatePincode = useCallback((p) => /^\d{6}$/.test(String(p || "")), []);
  
  const isOver18 = useCallback((dateString) => {
    if (!dateString) return false;
    const d = new Date(dateString);
    if (Number.isNaN(d.getTime())) return false;
    const today = new Date();
    let age = today.getFullYear() - d.getFullYear();
    const m = today.getMonth() - d.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < d.getDate())) age--;
    return age >= 18;
  }, []);

  const computeYears = useCallback((dob) => {
    if (!dob) return "";
    const bd = new Date(dob);
    if (isNaN(bd.getTime())) return "";
    const today = new Date();
    let yrs = today.getFullYear() - bd.getFullYear();
    const m = today.getMonth() - bd.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < bd.getDate())) yrs--;
    return String(yrs);
  }, []);

  // Responsive layout
  useEffect(() => {
    const updateIsMobile = () => setIsMobile(window.innerWidth <= 920);
    updateIsMobile();
    
    let resizeTimer;
    const handleResize = () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateIsMobile, 120);
    };
    
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  // Escape key to close
  useEffect(() => {
    const handleEsc = (e) => {
      if (e.key === "Escape") onClose();
    };
    document.addEventListener("keydown", handleEsc);
    return () => document.removeEventListener("keydown", handleEsc);
  }, [onClose]);

  // Auto-generate ID
  useEffect(() => {
    if (!isOpen) {
      setIdAutoGenerated(false);
      const idEl = document.querySelector('input[name="idNo"]');
      if (idEl) idEl.removeAttribute("disabled");
      return;
    }

    let mounted = true;

    async function fetchAndGenerateId() {
      try {
        const nodesToCheck = ["ExitStaffs", "StaffBioData", "WorkerBioData", "Staffs", "EmployeeData"];
        const allIds = [];

        for (const node of nodesToCheck) {
          try {
            const snap = await firebaseDB.child(node).once("value");
            const v = snap.val();
            if (!v) continue;
            
            Object.keys(v).forEach((k) => {
              const rec = v[k];
              if (!rec) return;
              
              const id = rec.idNo || rec.id || rec.empId || rec.employeeId || rec.ID;
              if (!id) return;
              
              const s = String(id).trim();
              if (s) allIds.push(s);
            });
          } catch (innerErr) {
            // Silently ignore read errors
          }
        }

        // Fallback
        if (allIds.length === 0) {
          try {
            const snap = await firebaseDB.child("StaffBioData").once("value");
            const v = snap.val();
            if (v) {
              Object.keys(v).forEach((k) => {
                const rec = v[k];
                if (!rec) return;
                
                const id = rec.idNo || rec.id || rec.empId || rec.employeeId || rec.ID;
                if (!id) return;
                
                const s = String(id).trim();
                if (s) allIds.push(s);
              });
            }
          } catch (e) {
            // Ignore
          }
        }

        let generated = "ST01";
        const normalized = allIds.map((x) => String(x).trim().toUpperCase()).filter(Boolean);

        if (normalized.length > 0) {
          // ST matches
          const stMatches = normalized
            .map((id) => {
              const m = id.match(/^ST(\d+)$/i);
              if (!m) return null;
              return { raw: id, num: parseInt(m[1], 10), digits: m[1].length };
            })
            .filter(Boolean);

          if (stMatches.length > 0) {
            let max = stMatches[0];
            for (let i = 1; i < stMatches.length; i++) {
              if (stMatches[i].num > max.num) max = stMatches[i];
            }
            const nextNum = max.num + 1;
            const padded = String(nextNum).padStart(max.digits, "0");
            generated = `ST${padded}`;
          } else {
            // Parse any PREFIX + digits
            const parsed = normalized
              .map((id) => {
                const m = id.match(/^([A-Z]+)(\d+)$/i);
                if (!m) return null;
                return { prefix: m[1].toUpperCase(), num: parseInt(m[2], 10), digits: m[2].length };
              })
              .filter(Boolean);

            if (parsed.length > 0) {
              const map = {};
              parsed.forEach((p) => {
                if (!map[p.prefix]) {
                  map[p.prefix] = { maxNum: p.num, digits: p.digits };
                } else {
                  if (p.num > map[p.prefix].maxNum) map[p.prefix].maxNum = p.num;
                  if (p.digits > map[p.prefix].digits) map[p.prefix].digits = p.digits;
                }
              });
              
              let chosenPrefix = null;
              let chosenNum = -Infinity;
              let chosenDigits = 0;
              
              Object.keys(map).forEach((pref) => {
                if (map[pref].maxNum > chosenNum) {
                  chosenNum = map[pref].maxNum;
                  chosenPrefix = pref;
                  chosenDigits = map[pref].digits;
                }
              });
              
              if (chosenPrefix) {
                const nextNum = chosenNum + 1;
                const padded = String(nextNum).padStart(chosenDigits, "0");
                generated = `${chosenPrefix}${padded}`;
              } else {
                generated = "ST01";
              }
            } else {
              generated = "ST01";
            }
          }
        } else {
          generated = "ST01";
        }

        if (!mounted) return;
        
        setFormData((prev) => ({ ...prev, idNo: generated }));
        setIdAutoGenerated(true);

        setTimeout(() => {
          const idEl = document.querySelector('input[name="idNo"]');
          if (idEl) idEl.setAttribute("disabled", "true");
        }, 30);
      } catch (err) {
        console.error("Auto ID generation error:", err);
        if (!mounted) return;
        
        setFormData((prev) => ({ ...prev, idNo: "ST01" }));
        setIdAutoGenerated(true);
        
        setTimeout(() => {
          const idEl = document.querySelector('input[name="idNo"]');
          if (idEl) idEl.setAttribute("disabled", "true");
        }, 30);
      }
    }

    fetchAndGenerateId();
    return () => { mounted = false; };
  }, [isOpen]);

  // Duplicate ID check
  const checkDuplicateId = useCallback(async (idNo) => {
    if (!idNo) return null;
    try {
      const q = await firebaseDB.child("StaffBioData").orderByChild("idNo").equalTo(idNo).once("value");
      const val = q.val();
      if (!val) {
        const q2 = await firebaseDB.child("ExitStaffs").orderByChild("idNo").equalTo(idNo).once("value");
        const val2 = q2.val();
        if (!val2) {
          const q3 = await firebaseDB.child("WorkerBioData").orderByChild("idNo").equalTo(idNo).once("value");
          const val3 = q3.val();
          if (!val3) return null;
          const key3 = Object.keys(val3)[0];
          return { recordId: key3, ...val3[key3] };
        }
        const key2 = Object.keys(val2)[0];
        return { recordId: key2, ...val2[key2] };
      }
      const key = Object.keys(val)[0];
      const rec = val[key];
      return { recordId: key, ...rec };
    } catch (err) {
      console.error("checkDuplicateId error:", err);
      return null;
    }
  }, []);

  // Handle ID Proof file uploads
  const handleIdProofChange = useCallback((e) => {
    const files = Array.from(e.target.files || []);
    
    const currentCount = formData.idProofFiles?.length || 0;
    if (currentCount + files.length > 5) {
      setErrors(prev => ({
        ...prev,
        idProof: "Maximum 5 ID proof files allowed"
      }));
      return;
    }
    
    const validFiles = [];
    const invalidFiles = [];
    
    files.forEach(file => {
      const validImage = ["image/jpeg", "image/jpg", "image/png", "image/gif"];
      const validPdf = "application/pdf";
      
      if ((validImage.includes(file.type) || file.type === validPdf) && file.size <= 200 * 1024) {
        validFiles.push(file);
      } else {
        invalidFiles.push(file.name);
      }
    });
    
    if (invalidFiles.length > 0) {
      setErrors(prev => ({
        ...prev,
        idProof: `Invalid files: ${invalidFiles.join(", ")}. Only PDF/JPG/PNG up to 200KB each`
      }));
    }
    
    if (validFiles.length > 0) {
      const imagePreviews = [];
      validFiles.forEach(file => {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = (e) => {
            imagePreviews.push(e.target.result);
            if (imagePreviews.length === validFiles.filter(f => f.type.startsWith('image/')).length) {
              setFormData(prev => ({
                ...prev,
                idProofPreviews: [...(prev.idProofPreviews || []), ...imagePreviews]
              }));
            }
          };
          reader.readAsDataURL(file);
        }
      });
      
      setFormData(prev => ({
        ...prev,
        idProofFiles: [...(prev.idProofFiles || []), ...validFiles]
      }));
      
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.idProof;
        return newErrors;
      });
    }
  }, [formData.idProofFiles]);

  // Remove ID Proof file
  const removeIdProofFile = useCallback((index) => {
    setFormData(prev => ({
      ...prev,
      idProofFiles: prev.idProofFiles.filter((_, i) => i !== index),
      idProofPreviews: prev.idProofPreviews.filter((_, i) => i !== index)
    }));
  }, []);

  // Central change handler - FIXED to prevent infinite loops
  const handleChange = useCallback((e) => {
    if (!e || !e.target) return;
    const { name, value, type, checked } = e.target;

    if (name === "idNo" && idAutoGenerated) {
      return;
    }

    // Mobile number validation
    if (name === "mobileNo1" || name === "mobileNo2" || name.includes("mobile1") || name.includes("mobile2")) {
      if (value && !/^\d*$/.test(value)) return;
      if (value.length > 10) return;
    }
    
    // Pincode validation
    if (name.toLowerCase().includes("pincode")) {
      if (value && !/^\d*$/.test(value)) return;
      if (value.length > 6) return;
    }

    // Handle "same as permanent address" checkbox - FIXED to prevent loops
    if (type === "checkbox" && name === "sameAsPermanent") {
      setFormData((prev) => {
        const newFormData = { ...prev };
        
        if (checked) {
          newFormData.sameAsPermanent = true;
          newFormData.presentAddress = prev.permanentAddress || "";
          newFormData.presentStreet = prev.permanentStreet || "";
          newFormData.presentLandmark = prev.permanentLandmark || "";
          newFormData.presentVillage = prev.permanentVillage || "";
          newFormData.presentMandal = prev.permanentMandal || "";
          newFormData.presentDistrict = prev.permanentDistrict || "";
          newFormData.presentState = prev.permanentState || "";
          newFormData.presentPincode = prev.permanentPincode || "";
        } else {
          newFormData.sameAsPermanent = false;
        }
        
        return newFormData;
      });
      
      // Clear errors for present address fields
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors.presentAddress;
        delete newErrors.presentStreet;
        delete newErrors.presentVillage;
        delete newErrors.presentMandal;
        delete newErrors.presentDistrict;
        delete newErrors.presentState;
        delete newErrors.presentPincode;
        return newErrors;
      });
      
      return;
    }

    // Handle nested emergency contact fields
    if (name.includes(".") && name.startsWith("emergencyContact")) {
      const [parent, field] = name.split(".");
      setFormData((prev) => ({ 
        ...prev, 
        [parent]: { 
          ...(prev[parent] || {}), 
          [field]: value 
        } 
      }));
      
      setErrors((prev) => { 
        const newErrors = { ...prev };
        if (newErrors[parent] && newErrors[parent][field]) {
          delete newErrors[parent][field];
        }
        return newErrors;
      });
      return;
    }

    // Handle date of birth
    if (name === "dateOfBirth") {
      const yrs = computeYears(value);
      setFormData((prev) => ({ 
        ...prev, 
        dateOfBirth: value, 
        years: yrs 
      }));
      
      setErrors((prev) => { 
        const newErrors = { ...prev };
        delete newErrors.dateOfBirth;
        delete newErrors.years;
        return newErrors;
      });
      return;
    }

    // Handle salary breakdown fields
    if (name.startsWith("salaryBreakdown.")) {
      const field = name.split(".")[1];
      setFormData(prev => ({
        ...prev,
        salaryBreakdown: {
          ...prev.salaryBreakdown,
          [field]: value
        }
      }));
      return;
    }

    // Handle deductions fields
    if (name.startsWith("deductions.")) {
      const field = name.split(".")[1];
      setFormData(prev => ({
        ...prev,
        deductions: {
          ...prev.deductions,
          [field]: value
        }
      }));
      return;
    }

    // Handle file upload for employee photo
    if (type === "file" && name === "employeePhoto") {
      const file = e.target.files?.[0] || null;
      if (!file) {
        setFormData((prev) => ({ ...prev, employeePhotoFile: null }));
        return;
      }
      
      const validTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif"];
      if (!validTypes.includes(file.type)) {
        setErrors((prev) => ({ ...prev, employeePhoto: "Only JPG/PNG/GIF allowed" }));
        return;
      }
      
      if (file.size > 100 * 1024) {
        setErrors((prev) => ({ ...prev, employeePhoto: "Image must be less than 100KB" }));
        return;
      }
      
      setFormData((prev) => ({ ...prev, employeePhotoFile: file }));
      setErrors((prev) => { 
        const newErrors = { ...prev };
        delete newErrors.employeePhoto;
        return newErrors;
      });
      return;
    }

    // Default case
    setFormData((prev) => ({ ...prev, [name]: value }));
    setErrors((prev) => { 
      const newErrors = { ...prev };
      if (newErrors[name]) delete newErrors[name];
      return newErrors;
    });
  }, [idAutoGenerated, computeYears]);

  // Look up staff by ID
  const findStaffByIdNo = useCallback(async (idNoRaw) => {
    const id = String(idNoRaw || "").trim();
    if (!id) return null;

    try {
      const q = await firebaseDB.child("StaffBioData").orderByChild("idNo").equalTo(id).once("value");
      const val = q.val();
      if (val) {
        const key = Object.keys(val)[0];
        const rec = val[key] || {};
        return { key, rec };
      }
    } catch (_) { }

    const up = id.toUpperCase();
    if (up !== id) {
      try {
        const q2 = await firebaseDB.child("StaffBioData").orderByChild("idNo").equalTo(up).once("value");
        const val2 = q2.val();
        if (val2) {
          const key = Object.keys(val2)[0];
          const rec = val2[key] || {};
          return { key, rec };
        }
      } catch (_) { }
    }

    return null;
  }, []);

  // Handle blur events
  const handleBlur = useCallback(async (e) => {
    if (!e || !e.target) return;
    const { name, value } = e.target;
    if (!name) return;

    const fieldErrors = {};
    
    if (name === "mobileNo1" || name === "mobileNo2") {
      if (value && !validateMobileNumber(value)) {
        fieldErrors[name] = "Mobile number must be 10 digits";
      }
    }
    
    if (name === "permanentPincode" || name === "presentPincode") {
      if (value && !validatePincode(value)) {
        fieldErrors[name] = "Pin code must be 6 digits";
      }
    }
    
    if (name === "dateOfBirth") {
      if (value && !isOver18(value)) {
        fieldErrors[name] = "Staff must be at least 18 years old";
      }
    }

    if (name === "idNo") {
      const id = (value || "").trim();
      if (id) {
        try {
          const existing = await checkDuplicateId(id);
          if (existing) {
            setExistingEmployee(existing);
            setShowIdExistsModal(true);
            fieldErrors.idNo = `ID already exists for ${existing.firstName || existing.name || ""} ${existing.lastName || ""}`.trim();
          } else {
            setExistingEmployee(null);
            setShowIdExistsModal(false);
          }
        } catch (err) {
          console.warn("Duplicate check failed", err);
        }
      }
    }

    if (name === "superiorId") {
      const raw = (value || "").trim();
      if (!raw) {
        setFormData(prev => ({ ...prev, superiorName: "" }));
      } else {
        try {
          const hit = await findStaffByIdNo(raw);
          if (hit && hit.rec) {
            const fn = String(hit.rec.firstName || "").trim();
            const ln = String(hit.rec.lastName || "").trim();
            const full = (fn || ln) ? `${fn} ${ln}`.trim() : (String(hit.rec.name || "").trim());
            setFormData(prev => ({ ...prev, superiorName: full || "" }));
            setErrors(prev => { 
              const newErrors = { ...prev };
              delete newErrors.superiorId;
              return newErrors;
            });
          } else {
            setFormData(prev => ({ ...prev, superiorName: "" }));
            setErrors(prev => ({ ...prev, superiorId: "No staff found with this ID" }));
          }
        } catch (err) {
          setFormData(prev => ({ ...prev, superiorName: "" }));
          setErrors(prev => ({ ...prev, superiorId: "Lookup failed — try again" }));
        }
      }
    }

    setErrors((prev) => ({ ...prev, ...fieldErrors }));
  }, [validateMobileNumber, validatePincode, isOver18, checkDuplicateId, findStaffByIdNo]);

  // Validation for each step
  const checkValidationForStep = useCallback((s) => {
    const e = {};
    switch (s) {
      case 1: {
        if (!formData.idNo || String(formData.idNo).trim() === "") e.idNo = "Enter ID No";
        else if (String(formData.idNo).trim().length < 3) e.idNo = "Enter Valid ID No";
        
        if (!formData.date || String(formData.date).trim() === "") e.date = "Enter Date of Joining";
        
        if (!formData.firstName || formData.firstName.trim() === "") e.firstName = "First name required";
        if (!formData.lastName || formData.lastName.trim() === "") e.lastName = "Last name required";
        
        if (!formData.gender) e.gender = "Gender is required";
        
        if (!formData.dateOfBirth) e.dateOfBirth = "DOB is required";
        else if (!isOver18(formData.dateOfBirth)) e.dateOfBirth = "Must be at least 18 years old";
        
        if (!formData.years) e.years = "Years is required";
        else {
          const num = Number(formData.years);
          if (!Number.isFinite(num) || num < 18 || num > 100) e.years = "Enter valid years";
        }
        
        if (!formData.mobileNo1) e.mobileNo1 = "Mobile No. 1 is required";
        else if (!validateMobileNumber(formData.mobileNo1)) e.mobileNo1 = "Mobile number must be 10 digits";
        
        if (formData.mobileNo2 && !validateMobileNumber(formData.mobileNo2)) {
          e.mobileNo2 = "Mobile number must be 10 digits";
        }
        
        if (!formData.idProofFiles || formData.idProofFiles.length === 0) {
          e.idProof = "At least one ID proof document is required";
        } else if (formData.idProofFiles.length > 5) {
          e.idProof = "Maximum 5 ID proof documents allowed";
        }
        
        if (formData.employeePhotoFile) {
          const file = formData.employeePhotoFile;
          const validTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif"];
          if (!validTypes.includes(file.type)) e.employeePhoto = "Only JPG/PNG/GIF allowed";
          if (file.size > 100 * 1024) e.employeePhoto = "Image must be less than 100KB";
        }
        break;
      }
      case 2: {
        if (!formData.permanentAddress || formData.permanentAddress.trim() === "") e.permanentAddress = "Address is required";
        if (!formData.permanentStreet || formData.permanentStreet.trim() === "") e.permanentStreet = "Street is required";
        if (!formData.permanentVillage || formData.permanentVillage.trim() === "") e.permanentVillage = "Village/Town is required";
        if (!formData.permanentMandal || formData.permanentMandal.trim() === "") e.permanentMandal = "Mandal is required";
        if (!formData.permanentDistrict || formData.permanentDistrict.trim() === "") e.permanentDistrict = "District is required";
        if (!formData.permanentState || formData.permanentState.trim() === "") e.permanentState = "State is required";
        if (!formData.permanentPincode) e.permanentPincode = "Pin Code is required";
        else if (!validatePincode(formData.permanentPincode)) e.permanentPincode = "Pin code must be 6 digits";
        break;
      }
      case 3: {
        // Only validate present address if not same as permanent
        if (!formData.sameAsPermanent) {
          if (!formData.presentAddress || formData.presentAddress.trim() === "") e.presentAddress = "Address is required";
          if (!formData.presentStreet || formData.presentStreet.trim() === "") e.presentStreet = "Street is required";
          if (!formData.presentVillage || formData.presentVillage.trim() === "") e.presentVillage = "Village/Town is required";
          if (!formData.presentMandal || formData.presentMandal.trim() === "") e.presentMandal = "Mandal is required";
          if (!formData.presentDistrict || formData.presentDistrict.trim() === "") e.presentDistrict = "District is required";
          if (!formData.presentState || formData.presentState.trim() === "") e.presentState = "State is required";
          if (!formData.presentPincode) e.presentPincode = "Pin Code is required";
          else if (!validatePincode(formData.presentPincode)) e.presentPincode = "Pin code must be 6 digits";
        }
        break;
      }
      case 4: {
        if (!formData.maritalStatus) e.maritalStatus = "Marital Status is required";
        if (!formData.religion) e.religion = "Religion is required";
        if (!formData.cast) e.cast = "Cast is required";
        break;
      }
      case 5: {
        if (!formData.qualification) e.qualification = "Qualification is required";
        if (!formData.primarySkill) e.primarySkill = "Primary Skill is required";
        if (!formData.motherTongue) e.motherTongue = "Mother Tongue is required";
        if (!formData.languages) e.languages = "Languages are required";
        break;
      }
      case 6:
        break;
      case 7: {
        const ec1 = formData.emergencyContact1 || {};
        if (!ec1.name) e["emergencyContact1.name"] = "Name required";
        if (!ec1.relation) e["emergencyContact1.relation"] = "Relation required";
        if (!ec1.mobile1) e["emergencyContact1.mobile1"] = "Mobile required";
        else if (!validateMobileNumber(ec1.mobile1)) e["emergencyContact1.mobile1"] = "Mobile must be 10 digits";
        break;
      }
      case 8: {
        const ec2 = formData.emergencyContact2 || {};
        if (!ec2.name) e["emergencyContact2.name"] = "Name required";
        if (!ec2.relation) e["emergencyContact2.relation"] = "Relation required";
        if (!ec2.mobile1) e["emergencyContact2.mobile1"] = "Mobile required";
        else if (!validateMobileNumber(ec2.mobile1)) e["emergencyContact2.mobile1"] = "Mobile must be 10 digits";
        break;
      }
      case 9:
        break;
      case 10: {
        if (!formData.department) e.department = "Select Department";
        if (!formData.designation) e.designation = "Select Designation";
        if (!formData.basicSalary) e.basicSalary = "Enter valid Salary";
        if (!formData.pageNo) e.pageNo = "Enter Page No";
        break;
      }
      case 11: {
        const pp = (formData.phonePayNo || "").trim();
        const gp = (formData.googlePayNo || "").trim();
        if (pp) {
          if (!validateMobileNumber(pp)) e.phonePayNo = "PhonePe/Pay number must be 10 digits";
          if (!formData.phonePayName || String(formData.phonePayName).trim() === "") e.phonePayName = "PhonePe/Pay name required";
        }
        if (gp) {
          if (!validateMobileNumber(gp)) e.googlePayNo = "Google Pay number must be 10 digits";
          if (!formData.googlePayName || String(formData.googlePayName).trim() === "") e.googlePayName = "Google Pay name required";
        }
        break;
      }
      case 12: {
        if (!formData.salaryEffectiveDate) e.salaryEffectiveDate = "Effective date is required";
        if (!formData.paymentMode) e.paymentMode = "Payment mode is required";
        const basicSalary = formData.salaryBreakdown?.basic || "0";
        if (!basicSalary || isNaN(basicSalary) || Number(basicSalary) <= 0) {
          e["salaryBreakdown.basic"] = "Valid basic salary is required";
        }
        break;
      }
      default: break;
    }
    return e;
  }, [formData, validateMobileNumber, validatePincode, isOver18]);

  const mapErrorsForChildren = useCallback((errs) => {
    const out = {};
    Object.keys(errs || {}).forEach((k) => {
      if (k.includes(".")) {
        const parts = k.split(".");
        let cur = out;
        for (let i = 0; i < parts.length; i++) {
          const p = parts[i];
          if (i === parts.length - 1) cur[p] = errs[k];
          else { cur[p] = cur[p] || {}; cur = cur[p]; }
        }
      } else {
        out[k] = errs[k];
      }
    });
    return out;
  }, []);

  const validateCurrentStep = useCallback((s) => {
    const e = checkValidationForStep(s);
    if (Object.keys(e).length > 0) {
      const nested = mapErrorsForChildren(e);
      setErrors((prev) => ({ ...prev, ...e, ...nested }));
      
      setTimeout(() => {
        const firstKey = Object.keys(e)[0];
        const sel = `[name="${firstKey}"]`;
        const el = document.querySelector(sel) || 
                   document.querySelector(`[name="${firstKey.replace(/\./g, '][')}"]`);
        if (el && el.focus) el.focus();
      }, 50);
      return false;
    }
    
    setErrors((prev) => {
      const newErrors = { ...prev };
      Object.keys(e).forEach((k) => { 
        if (newErrors[k]) delete newErrors[k]; 
      });
      
      Object.keys(e).forEach((k) => {
        if (k.includes(".")) {
          const [parent, child] = k.split(".");
          if (newErrors[parent] && newErrors[parent][child]) { 
            delete newErrors[parent][child]; 
            if (Object.keys(newErrors[parent]).length === 0) delete newErrors[parent]; 
          }
        }
      });
      return newErrors;
    });
    
    return true;
  }, [checkValidationForStep, mapErrorsForChildren]);

  const validateAllAndJump = useCallback(async () => {
    for (let s = 1; s <= TOTAL_STEPS; s += 1) {
      const e = checkValidationForStep(s);
      if (Object.keys(e).length > 0) {
        const nested = mapErrorsForChildren(e);
        setErrors((prev) => ({ ...prev, ...e, ...nested }));
        setStep(s);
        
        setTimeout(() => {
          const firstKey = Object.keys(e)[0];
          const el = document.querySelector(`[name="${firstKey}"]`);
          if (el && el.focus) el.focus();
        }, 80);
        return false;
      }
    }
    
    const id = (formData.idNo || "").trim();
    if (id) {
      const existing = await checkDuplicateId(id);
      if (existing) {
        setExistingEmployee(existing);
        setShowIdExistsModal(true);
        setErrors((prev) => ({ ...prev, idNo: "ID already exists" }));
        setStep(1);
        return false;
      }
    }
    return true;
  }, [checkValidationForStep, mapErrorsForChildren, checkDuplicateId, formData.idNo]);

  // Main submission handler - FIXED to handle undefined values
  const handlePrimaryAction = useCallback(async (ev) => {
    ev?.preventDefault?.();
    
    if (step < TOTAL_STEPS) {
      if (validateCurrentStep(step)) {
        setStep((s) => Math.min(TOTAL_STEPS, s + 1));
      }
      return;
    }
    
    if (!(await validateAllAndJump())) return;

    setIsSubmitting(true);
    
    try {
      let photoURL = DEFAULT_PHOTO_URL;
      let idProofURLs = [];
      
      // Upload employee photo
      if (formData.employeePhotoFile) {
        try {
          const ext = formData.employeePhotoFile.name.split(".").pop();
          const fileName = `staff-photos/${(formData.idNo || "unknown")}-${Date.now()}.${ext}`;
          const fileRef = storageRef.child(fileName);
          
          setUploadProgress(prev => ({
            ...prev,
            [formData.employeePhotoFile.name]: 0
          }));
          
          const result = await uploadFile(
            fileRef, 
            formData.employeePhotoFile,
            (progress) => {
              setUploadProgress(prev => ({
                ...prev,
                [formData.employeePhotoFile.name]: progress
              }));
            }
          );
          
          // Ensure we have a valid URL
          photoURL = result?.downloadURL || DEFAULT_PHOTO_URL;
        } catch (photoError) {
          console.error("Photo upload failed:", photoError);
          photoURL = DEFAULT_PHOTO_URL;
        }
      }
      
      // Upload ID proof files
      if (formData.idProofFiles && formData.idProofFiles.length > 0) {
        for (const file of formData.idProofFiles) {
          try {
            const ext = file.name.split(".").pop();
            const fileName = `id-proofs/${(formData.idNo || "unknown")}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}.${ext}`;
            const fileRef = storageRef.child(fileName);
            
            setUploadProgress(prev => ({
              ...prev,
              [file.name]: 0
            }));
            
            const result = await uploadFile(
              fileRef, 
              file,
              (progress) => {
                setUploadProgress(prev => ({
                  ...prev,
                  [file.name]: progress
                }));
              }
            );
            
            idProofURLs.push({
              url: result?.downloadURL || "",
              name: file.name,
              type: file.type,
              size: file.size
            });
            
            setUploadProgress(prev => ({
              ...prev,
              [file.name]: 100
            }));
          } catch (error) {
            console.error(`Failed to upload ${file.name}:`, error);
            setUploadProgress(prev => ({
              ...prev,
              [file.name]: -1
            }));
            // Continue with other files even if one fails
          }
        }
      }
      
      // Calculate salary totals
      const salaryBreakdown = { ...formData.salaryBreakdown };
      const deductions = { ...formData.deductions };
      
      // Ensure all salary fields have values
      const basic = parseFloat(salaryBreakdown.basic) || 0;
      const hra = parseFloat(salaryBreakdown.hra) || 0;
      const da = parseFloat(salaryBreakdown.da) || 0;
      const ta = parseFloat(salaryBreakdown.ta) || 0;
      const medical = parseFloat(salaryBreakdown.medical) || 0;
      const specialAllowance = parseFloat(salaryBreakdown.specialAllowance) || 0;
      const otherAllowances = parseFloat(salaryBreakdown.otherAllowances) || 0;
      
      salaryBreakdown.totalEarnings = String(
        basic + hra + da + ta + medical + specialAllowance + otherAllowances
      );
      
      // Ensure all deduction fields have values
      const pf = parseFloat(deductions.pf) || 0;
      const esi = parseFloat(deductions.esi) || 0;
      const tds = parseFloat(deductions.tds) || 0;
      const otherDeductions = parseFloat(deductions.otherDeductions) || 0;
      
      deductions.totalDeductions = String(pf + esi + tds + otherDeductions);
      
      const totalEarnings = parseFloat(salaryBreakdown.totalEarnings) || 0;
      const totalDeductions = parseFloat(deductions.totalDeductions) || 0;
      const netSalary = totalEarnings - totalDeductions;
      
      // Prepare submission data with all required fields
      const submitData = {
        ...formData,
        employeePhoto: photoURL, // Always has a value
        idProof: idProofURLs,
        salaryBreakdown: {
          basic: String(basic),
          hra: String(hra),
          da: String(da),
          ta: String(ta),
          medical: String(medical),
          specialAllowance: String(specialAllowance),
          otherAllowances: String(otherAllowances),
          totalEarnings: salaryBreakdown.totalEarnings
        },
        deductions: {
          pf: String(pf),
          esi: String(esi),
          tds: String(tds),
          otherDeductions: String(otherDeductions),
          totalDeductions: deductions.totalDeductions
        },
        netSalary: String(netSalary > 0 ? netSalary : 0),
        rating: Number(formData.rating || 0),
        createdById: formData.createdById || "",
        createdByName: formData.createdByName || "",
        createdAt: formData.createdAt || new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // Remove temporary file fields
      delete submitData.employeePhotoFile;
      delete submitData.idProofFiles;
      delete submitData.idProofPreviews;

      // Clean undefined values before submission
      const cleanedData = cleanUndefinedValues(submitData);
      
      // Save to Firebase
      const listRef = firebaseDB.child("StaffBioData");
      const newRef = listRef.push();
      await newRef.set(cleanedData);
      
      const recordId = newRef.key;
      const name = `${formData.firstName || ""} ${formData.lastName || ""}`.trim();

      setSuccessInfo({ idNo: formData.idNo, name, recordId });
      setSuccessOpen(true);

      if (typeof onSaved === "function") {
        try { 
          onSaved({ id: recordId, ...cleanedData }); 
        } catch (err) { 
          console.error("Error in onSaved callback:", err); 
        }
      }

      // Reset form
      setFormData({ ...initialFormData });
      setErrors({});
      setStep(1);
      setIdAutoGenerated(false);
      setUploadProgress({});
      
      const idEl = document.querySelector('input[name="idNo"]');
      if (idEl) idEl.removeAttribute("disabled");
      
    } catch (err) {
      console.error("Submit error:", err);
      alert("Error submitting form: " + (err?.message || "Unknown error"));
    } finally { 
      setIsSubmitting(false); 
    }
  }, [
    step, 
    validateCurrentStep, 
    validateAllAndJump, 
    formData, 
    onSaved
  ]);

  const handlePrev = useCallback((ev) => {
    ev?.preventDefault?.();
    if (step > 1) setStep((s) => s - 1);
  }, [step]);

  const renderStep = useCallback((s) => {
    const childErrors = mapErrorsForChildren(errors);
    const common = {
      formData,
      errors: childErrors,
      handleChange,
      handleBlur,
      handleFileChange: handleChange,
      handleIdProofChange,
      removeIdProofFile,
      nextStep: () => setStep((p) => Math.min(TOTAL_STEPS, p + 1)),
      prevStep: () => setStep((p) => Math.max(1, p - 1)),
      uploadProgress,
    };
    
    switch (s) {
      case 1: return <BasicInformation {...common} />;
      case 2: return <PermanentAddress {...common} />;
      case 3: return <PresentAddress {...common} />;
      case 4: return <PersonalInformation {...common} />;
      case 5: return <QualificationSkills {...common} />;
      case 6: return <HealthDetails {...common} />;
      case 7: return <EmergencyContact1 {...common} />;
      case 8: return <EmergencyContact2 {...common} />;
      case 9: return <EmergencyContact3 {...common} />;
      case 10: return <Designation {...common} />;
      case 11: return <BankDetails {...common} />;
      case 12: return <SalaryProfile {...common} handleSubmit={handlePrimaryAction} isSubmitting={isSubmitting} />;
      default: return null;
    }
  }, [formData, errors, handleChange, handleBlur, handleIdProofChange, removeIdProofFile, uploadProgress, handlePrimaryAction, isSubmitting, mapErrorsForChildren]);

  // Success Modal Component
  const SuccessModal = useCallback(({ open, onClose, info }) => {
    if (!open) return null;
    const { idNo, name } = info || {};
    
    return (
      <div className="wb-success-backdrop" onClick={onClose}>
        <div className="wb-success-card bg-warning" onClick={(e) => e.stopPropagation()}>
          <div className="wb-success-title text-black">Saved Successfully</div>
          <div className="wb-success-sub text-black">ID No: {idNo || "—"}</div>
          <div className="wb-success-sub text-black">{name || "—"}</div>
          <div style={{ display: "flex", justifyContent: "flex-end", marginTop: 12 }}>
            <button 
              className="btn btn-primary" 
              onClick={() => { 
                onClose();
                setSuccessOpen(false); 
              }}
            >
              Done
            </button>
          </div>
        </div>
      </div>
    );
  }, []);

  // ID Exists Modal Component
  const IdExistsModal = useCallback(() => {
    if (!showIdExistsModal || !existingEmployee) return null;
    
    const name = `${existingEmployee.firstName || existingEmployee.name || ""} ${existingEmployee.lastName || ""}`.trim();
    
    return (
      <div className="modal-backdrop-custom" role="dialog" aria-modal="true" onClick={() => setShowIdExistsModal(false)}>
        <div className="modal-card-custom" onClick={(e) => e.stopPropagation()}>
          <div className="modal-header-custom">
            <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
              <div style={{ 
                width: 44, 
                height: 44, 
                borderRadius: 10, 
                background: "linear-gradient(135deg,#ff7a7a,#ffb677)", 
                display: "flex", 
                alignItems: "center", 
                justifyContent: "center", 
                color: "#fff", 
                fontWeight: 700 
              }}>
                ID
              </div>
              <div>
                <h5 style={{ margin: 0 }}>ID Already Exists</h5>
                <small style={{ color: "#6b7280" }}>Please choose a different ID</small>
              </div>
            </div>
            <button 
              className="btn-close-custom" 
              aria-label="Close" 
              onClick={() => setShowIdExistsModal(false)}
            >
              ✕
            </button>
          </div>

          <div className="modal-body-custom">
            <p style={{ marginBottom: 8 }}>This ID number is already associated with an existing staff:</p>
            <div style={{ display: "grid", gridTemplateColumns: "120px 1fr", gap: 6, marginBottom: 8 }}>
              <div style={{ color: "#6b7280" }}>Name</div>
              <div style={{ fontWeight: 600 }}>{name || "N/A"}</div>
              <div style={{ color: "#6b7280" }}>Record ID</div>
              <div style={{ fontFamily: "monospace", color: "#0f172a" }}>{existingEmployee.recordId || "N/A"}</div>
            </div>
            <div style={{ color: "#6b7280", fontSize: 13 }}>
              You can close this dialog and modify the ID, or contact administration if this is unexpected.
            </div>
          </div>

          <div className="modal-footer-custom">
            <button 
              className="btn btn-secondary" 
              onClick={() => setShowIdExistsModal(false)}
            >
              Close
            </button>
          </div>
        </div>
      </div>
    );
  }, [showIdExistsModal, existingEmployee]);

  if (!isOpen) return null;

  return (
    <>
      <div className="wb-backdrop" onClick={onClose}>
        <div 
          className="wb-card" 
          onClick={(e) => e.stopPropagation()} 
          role="dialog" 
          aria-modal="true" 
          aria-labelledby="staffFormTitle"
        >
          <div className="wb-header">
            <div style={{ display: "flex", flexDirection: "column" }}>
              <div id="staffFormTitle" className="wb-title">Staff / Staff Form</div>
              <div className="wb-step-counter">Step {step} of {TOTAL_STEPS}</div>
            </div>
            <div>
              <button className="wb-close-btn" title="Close" onClick={onClose}>✕</button>
            </div>
          </div>

          <div className="wb-body">
            {!isMobile && (
              <div className="wb-sidebar" aria-hidden>
                {Array.from({ length: TOTAL_STEPS }).map((_, i) => {
                  const idx = i + 1;
                  return (
                    <button
                      key={idx}
                      type="button"
                      className={`wb-step-btn ${step === idx ? "active" : ""}`}
                      onClick={() => setStep(idx)}
                    >
                      {idx}. {stepTitleFor(idx)}
                    </button>
                  );
                })}
              </div>
            )}

            <div className="wb-content">
              {isMobile ? (
                <div>
                  {Array.from({ length: TOTAL_STEPS }).map((_, i) => {
                    const idx = i + 1;
                    return (
                      <div className="wb-accordion-item" key={idx}>
                        <button 
                          className="wb-accordion-header" 
                          onClick={() => setStep(idx)} 
                          aria-expanded={step === idx}
                        >
                          <span>{idx}. {stepTitleFor(idx)}</span>
                          <span className="wb-accordion-arrow">{step === idx ? "▾" : "▸"}</span>
                        </button>
                        {step === idx && <div className="wb-accordion-body">{renderStep(idx)}</div>}
                      </div>
                    );
                  })}
                </div>
              ) : (
                <div>{renderStep(step)}</div>
              )}
            </div>
          </div>

          <div className="wb-footer">
            <button 
              className="wb-secondary-btn me-2" 
              onClick={handlePrev} 
              disabled={step <= 1}
            >
              Previous
            </button>
            <button 
              className="wb-primary-btn" 
              onClick={handlePrimaryAction} 
              disabled={isSubmitting}
            >
              {step < TOTAL_STEPS ? "Continue" : (isSubmitting ? "Saving..." : "Submit")}
            </button>
          </div>
        </div>
      </div>

      <SuccessModal 
        open={successOpen} 
        onClose={() => setSuccessOpen(false)} 
        info={successInfo} 
      />
      <IdExistsModal />
    </>
  );
};

function stepTitleFor(idx) {
  switch (idx) {
    case 1: return "Basic Info";
    case 2: return "Permanent Address";
    case 3: return "Present Address";
    case 4: return "Personal Info";
    case 5: return "Qualification & Skills";
    case 6: return "Health Details";
    case 7: return "Emergency 1";
    case 8: return "Emergency 2";
    case 9: return "Emergency 3";
    case 10: return "Designation & Job";
    case 11: return "Bank & Pay";
    case 12: return "Salary Profile";
    default: return `Step ${idx}`;
  }
}

export default StaffBioDataForm;